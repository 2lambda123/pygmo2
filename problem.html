

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Problem class &mdash; pygmo 2.14.1 documentation</title>
  

  
  
    <link rel="shortcut icon" href="_static/logo_favico.ico"/>
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Population class" href="population.html" />
    <link rel="prev" title="Algorithm class" href="algorithm.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> pygmo
          

          
          </a>

          
            
            
              <div class="version">
                2.14.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview.html">Capabilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/tutorials.html">Tutorials</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="api_reference.html">API reference</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="api_reference.html#core-classes">Core classes</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="algorithm.html">Algorithm class</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Problem class</a></li>
<li class="toctree-l3"><a class="reference internal" href="population.html">Population class</a></li>
<li class="toctree-l3"><a class="reference internal" href="island.html">Island class</a></li>
<li class="toctree-l3"><a class="reference internal" href="archipelago.html">Archipelago class</a></li>
<li class="toctree-l3"><a class="reference internal" href="bfe.html">Batch fitness evaluator</a></li>
<li class="toctree-l3"><a class="reference internal" href="topology.html">Topology</a></li>
<li class="toctree-l3"><a class="reference internal" href="r_policy.html">Replacement policy</a></li>
<li class="toctree-l3"><a class="reference internal" href="s_policy.html">Selection policy</a></li>
<li class="toctree-l3"><a class="reference internal" href="misc.html">Miscellanea</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api_reference.html#implemented-user-defined-classes">Implemented user-defined classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="api_reference.html#utilities">Utilities</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="credits.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="known_issues.html">Known issues</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pygmo</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="api_reference.html">API reference</a> &raquo;</li>
        
      <li>Problem class</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/problem.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="problem-class">
<h1>Problem class<a class="headerlink" href="#problem-class" title="Permalink to this headline">¶</a></h1>
<img alt="_images/prob_no_text.png" src="_images/prob_no_text.png" />
<dl class="class">
<dt id="pygmo.problem">
<em class="property">class </em><code class="sig-prename descclassname">pygmo.</code><code class="sig-name descname">problem</code><span class="sig-paren">(</span><em class="sig-param">udp = null_problem()</em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem" title="Permalink to this definition">¶</a></dt>
<dd><p>Problem class.</p>
<p>This class represents a generic <em>mathematical programming</em> or <em>evolutionary optimization</em> problem in the form:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{rl}
\mbox{find:}      &amp; \mathbf {lb} \le \mathbf x \le \mathbf{ub}\\
\mbox{to minimize: } &amp; \mathbf f(\mathbf x, s) \in \mathbb R^{n_{obj}}\\
\mbox{subject to:} &amp; \mathbf {c}_e(\mathbf x, s) = 0 \\
                  &amp; \mathbf {c}_i(\mathbf x, s) \le 0
\end{array}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf x \in \mathbb R^{n_{cx}} \times  \mathbb Z^{n_{ix}}\)</span> is called <em>decision vector</em> or
<em>chromosome</em>, and is made of <span class="math notranslate nohighlight">\(n_{cx}\)</span> real numbers and <span class="math notranslate nohighlight">\(n_{ix}\)</span> integers (all represented as doubles). The
total problem dimension is then indicated with <span class="math notranslate nohighlight">\(n_x = n_{cx} + n_{ix}\)</span>. <span class="math notranslate nohighlight">\(\mathbf{lb}, \mathbf{ub} \in
\mathbb R^{n_{cx}} \times  \mathbb Z^{n_{ix}}\)</span> are the <em>box-bounds</em>, <span class="math notranslate nohighlight">\(\mathbf f: \mathbb R^{n_{cx}} \times
\mathbb Z^{n_{ix}} \rightarrow \mathbb R^{n_{obj}}\)</span> define the <em>objectives</em>, <span class="math notranslate nohighlight">\(\mathbf c_e:  \mathbb R^{n_{cx}}
\times  \mathbb Z^{n_{ix}} \rightarrow \mathbb R^{n_{ec}}\)</span> are non linear <em>equality constraints</em>, and <span class="math notranslate nohighlight">\(\mathbf
c_i:  \mathbb R^{n_{cx}} \times  \mathbb Z^{n_{ix}} \rightarrow \mathbb R^{n_{ic}}\)</span> are non linear <em>inequality
constraints</em>. Note that the objectives and constraints may also depend from an added value <span class="math notranslate nohighlight">\(s\)</span> seeding the
values of any number of stochastic variables. This allows also for stochastic programming tasks to be represented by
this class. A tolerance is also considered for all constraints and set, by default, to zero. It can be modified
via the <a class="reference internal" href="#pygmo.problem.c_tol" title="pygmo.problem.c_tol"><code class="xref py py-attr docutils literal notranslate"><span class="pre">c_tol</span></code></a> attribute.</p>
<p>In order to define an optimizaztion problem in pygmo, the user must first define a class
whose methods describe the properties of the problem and allow to compute
the objective function, the gradient, the constraints, etc. In pygmo, we refer to such
a class as a <strong>user-defined problem</strong>, or UDP for short. Once defined and instantiated,
a UDP can then be used to construct an instance of this class, <a class="reference internal" href="#pygmo.problem" title="pygmo.problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">problem</span></code></a>, which
provides a generic interface to optimization problems.</p>
<p>Every UDP must implement at least the following two methods:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fitness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dv</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">get_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">fitness()</span></code> method is expected to return the fitness of the input decision vector (concatenating
the objectives, the equality and the inequality constraints), while
<code class="docutils literal notranslate"><span class="pre">get_bounds()</span></code> is expected to return the box bounds of the problem,
<span class="math notranslate nohighlight">\((\mathbf{lb}, \mathbf{ub})\)</span>, which also implicitly define the dimension of the problem.
The <code class="docutils literal notranslate"><span class="pre">fitness()</span></code> and <code class="docutils literal notranslate"><span class="pre">get_bounds()</span></code> methods of the UDP are accessible from the corresponding
<a class="reference internal" href="#pygmo.problem.fitness" title="pygmo.problem.fitness"><code class="xref py py-func docutils literal notranslate"><span class="pre">pygmo.problem.fitness()</span></code></a> and <a class="reference internal" href="#pygmo.problem.get_bounds" title="pygmo.problem.get_bounds"><code class="xref py py-func docutils literal notranslate"><span class="pre">pygmo.problem.get_bounds()</span></code></a>
methods (see their documentation for information on how the two methods should be implemented
in the UDP and other details).</p>
<p>The two mandatory methods above allow to define a single objective, deterministic, derivative-free, unconstrained
optimization problem. In order to consider more complex cases, the UDP may implement one or more of the following
methods:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_nobj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">get_nec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">get_nic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">get_nix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">batch_fitness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dvs</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">has_batch_fitness</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">has_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dv</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">has_gradient_sparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">gradient_sparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">has_hessians</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">hessians</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dv</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">has_hessians_sparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">hessians_sparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">has_set_seed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">set_seed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">get_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
<span class="k">def</span> <span class="nf">get_extra_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>See the documentation of the corresponding methods in this class for details on how the optional
methods in the UDP should be implemented and on how they are used by <a class="reference internal" href="#pygmo.problem" title="pygmo.problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">problem</span></code></a>.
Note that the exposed C++ problems can also be used as UDPs, even if they do not expose any of the
mandatory or optional methods listed above (see <a class="reference internal" href="problems.html#problems"><span class="std std-ref">here</span></a> for the
full list of UDPs already coded in pygmo).</p>
<p>This class is the Python counterpart of the C++ class <a class="reference external" href="https://esa.github.io/pagmo2/docs/cpp/problem.html#_CPPv4N5pagmo7problemE" title="(in pagmo v2.14.0)"><code class="docutils literal notranslate"><span class="pre">:problem</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>udp</strong> – a user-defined problem, either C++ or Python</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#NotImplementedError" title="(in Python v3.8)"><strong>NotImplementedError</strong></a> – if <em>udp</em> does not implement the mandatory methods detailed above</p></li>
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.8)"><strong>ValueError</strong></a> – if the number of objectives of the UDP is zero, the number of objectives,
    equality or inequality constraints is larger than an implementation-defined value,
    the problem bounds are invalid (e.g., they contain NaNs, the dimensionality of the lower bounds is
    different from the dimensionality of the upper bounds, etc. - note that infinite bounds are allowed),
    or if the <code class="docutils literal notranslate"><span class="pre">gradient_sparsity()</span></code> and <code class="docutils literal notranslate"><span class="pre">hessians_sparsity()</span></code> methods of the UDP fail basic sanity checks
    (e.g., they return vectors with repeated indices, they contain indices exceeding the problem’s dimensions, etc.)</p></li>
<li><p><strong>unspecified</strong> – any exception thrown by methods of the UDP invoked during construction,
    the deep copy of the UDP, the constructor of the underlying C++ class,
    failures at the intersection between C++ and Python (e.g., type conversion errors, mismatched function
    signatures, etc.)</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="pygmo.problem.batch_fitness">
<code class="sig-name descname">batch_fitness</code><span class="sig-paren">(</span><em class="sig-param">dvs</em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.batch_fitness" title="Permalink to this definition">¶</a></dt>
<dd><p>This method implements the evaluation of multiple decision vectors in batch mode
by invoking the <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> method of the UDP. The <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code>
method of the UDP accepts in input a batch of decision vectors, <em>dvs</em>, stored contiguously:
for a problem with dimension <span class="math notranslate nohighlight">\(n\)</span>, the first decision vector in <em>dvs</em> occupies
the index range <span class="math notranslate nohighlight">\(\left[0, n\right)\)</span>, the second decision vector occupies the range
<span class="math notranslate nohighlight">\(\left[n, 2n\right)\)</span>, and so on. The return value is the batch of fitness vectors <em>fvs</em>
resulting from computing the fitness of the input decision vectors.
<em>fvs</em> is also stored contiguously: for a problem with fitness dimension <span class="math notranslate nohighlight">\(f\)</span>, the first fitness
vector will occupy the index range <span class="math notranslate nohighlight">\(\left[0, f\right)\)</span>, the second fitness vector
will occupy the range <span class="math notranslate nohighlight">\(\left[f, 2f\right)\)</span>, and so on.</p>
<p>If the UDP provides a <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> method, this method will forward <code class="docutils literal notranslate"><span class="pre">dvs</span></code>
to the <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> method of the UDP after sanity checks. The output of the <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code>
method of the UDP will also be checked before being returned. If the UDP does not provide a
<code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> method, an error will be raised.</p>
<p>A successful call of this method will increase the internal fitness evaluation counter
(see <a class="reference internal" href="#pygmo.problem.get_fevals" title="pygmo.problem.get_fevals"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_fevals()</span></code></a>).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> method of the UDP must be able to take as input the decision vectors as a 1D NumPy array,
and it must return the fitness vectors as an iterable Python object (e.g., 1D NumPy array, list, tuple, etc.).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dvs</strong> (<em>array-like object</em>) – the decision vectors (chromosomes) to be evaluated in batch mode</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the fitness vectors of <em>dvs</em></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>1D NumPy float array</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.8)"><strong>ValueError</strong></a> – if <em>dvs</em> and/or the return value are not compatible with the problem’s properties</p></li>
<li><p><strong>unspecified</strong> – any exception thrown by the <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> method of the UDP, or by failures at the intersection
    between C++ and Python (e.g., type conversion errors, mismatched function signatures, etc.)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.c_tol">
<em class="property">property </em><code class="sig-name descname">c_tol</code><a class="headerlink" href="#pygmo.problem.c_tol" title="Permalink to this definition">¶</a></dt>
<dd><p>Constraints tolerance.</p>
<p>This property contains an array of <code class="docutils literal notranslate"><span class="pre">float</span></code> that are used when checking for constraint feasibility.
The dimension of the array is <span class="math notranslate nohighlight">\(n_{ec} + n_{ic}\)</span> (i.e., the total number of constraints), and
the array is zero-filled on problem construction.</p>
<p>This property can also be set via a scalar, instead of an array. In such case, all the tolerances
will be set to the provided scalar value.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the constraints’ tolerances</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>1D NumPy float array</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.8)"><strong>ValueError</strong></a> – if, when setting this property, the size of the input array differs from the number
    of constraints of the problem or if any element of the array is negative or NaN</p></li>
<li><p><strong>unspecified</strong> – any exception thrown by failures at the intersection between C++ and Python (e.g.,
    type conversion errors, mismatched function signatures, etc.)</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pygmo</span> <span class="kn">import</span> <span class="n">problem</span><span class="p">,</span> <span class="n">hock_schittkowsky_71</span> <span class="k">as</span> <span class="n">hs71</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prob</span> <span class="o">=</span> <span class="n">problem</span><span class="p">(</span><span class="n">hs71</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prob</span><span class="o">.</span><span class="n">c_tol</span>
<span class="go">array([0., 0.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prob</span><span class="o">.</span><span class="n">c_tol</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prob</span><span class="o">.</span><span class="n">c_tol</span>
<span class="go">array([1., 2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prob</span><span class="o">.</span><span class="n">c_tol</span> <span class="o">=</span> <span class="o">.</span><span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prob</span><span class="o">.</span><span class="n">c_tol</span>
<span class="go">array([0.5, 0.5])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.extract">
<code class="sig-name descname">extract</code><span class="sig-paren">(</span><em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.extract" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the user-defined problem.</p>
<p>This method allows to extract a reference to the user-defined problem (UDP) stored within this
<a class="reference internal" href="#pygmo.problem" title="pygmo.problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">problem</span></code></a> instance. The behaviour of this function depends on the value
of <em>t</em> (which must be a <a class="reference external" href="https://docs.python.org/3/library/functions.html#type" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a>) and on the type of the internal UDP:</p>
<ul class="simple">
<li><p>if the type of the UDP is <em>t</em>, then a reference to the UDP will be returned
(this mirrors the behaviour of the corresponding C++ method
<a class="reference external" href="https://esa.github.io/pagmo2/docs/cpp/problem.html#_CPPv4I0ENK5pagmo7problem7extractEPK1Tv" title="(in pagmo v2.14.0)"><code class="docutils literal notranslate"><span class="pre">:problem::extract()</span></code></a>),</p></li>
<li><p>if <em>t</em> is <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> and the UDP is a Python object (as opposed to an
<a class="reference internal" href="problems.html#problems-cpp"><span class="std std-ref">exposed C++ problem</span></a>), then a reference to the
UDP will be returned (this allows to extract a Python UDP without knowing its type),</p></li>
<li><p>otherwise, <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.8)"><code class="xref py py-data docutils literal notranslate"><span class="pre">None</span></code></a> will be returned.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>t</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#type" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a>) – the type of the user-defined problem to extract</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a reference to the internal user-defined problem, or <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.8)"><code class="xref py py-data docutils literal notranslate"><span class="pre">None</span></code></a> if the extraction fails</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#TypeError" title="(in Python v3.8)"><strong>TypeError</strong></a> – if <em>t</em> is not a <a class="reference external" href="https://docs.python.org/3/library/functions.html#type" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pygmo</span> <span class="k">as</span> <span class="nn">pg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">problem</span><span class="p">(</span><span class="n">pg</span><span class="o">.</span><span class="n">rosenbrock</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">pg</span><span class="o">.</span><span class="n">rosenbrock</span><span class="p">)</span> 
<span class="go">&lt;pygmo.core.rosenbrock at 0x7f56b870fd50&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">pg</span><span class="o">.</span><span class="n">ackley</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">prob</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">fitness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">get_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="p">([</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">problem</span><span class="p">(</span><span class="n">prob</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span> 
<span class="go">&lt;__main__.prob at 0x7f56a66b6588&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">prob</span><span class="p">)</span> 
<span class="go">&lt;__main__.prob at 0x7f56a66b6588&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">pg</span><span class="o">.</span><span class="n">rosenbrock</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.feasibility_f">
<code class="sig-name descname">feasibility_f</code><span class="sig-paren">(</span><em class="sig-param">f</em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.feasibility_f" title="Permalink to this definition">¶</a></dt>
<dd><p>This method will check the feasibility of a fitness vector <em>f</em> against the tolerances returned by
<a class="reference internal" href="#pygmo.problem.c_tol" title="pygmo.problem.c_tol"><code class="xref py py-attr docutils literal notranslate"><span class="pre">c_tol</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>f</strong> (<em>array-like object</em>) – a fitness vector</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if the fitness vector is feasible, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.8)"><strong>ValueError</strong></a> – if the size of <em>f</em> is not the same as the output of
    <a class="reference internal" href="#pygmo.problem.get_nf" title="pygmo.problem.get_nf"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_nf()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.feasibility_x">
<code class="sig-name descname">feasibility_x</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.feasibility_x" title="Permalink to this definition">¶</a></dt>
<dd><p>This method will check the feasibility of the fitness corresponding to a decision vector <em>x</em> against
the tolerances returned by <a class="reference internal" href="#pygmo.problem.c_tol" title="pygmo.problem.c_tol"><code class="xref py py-attr docutils literal notranslate"><span class="pre">c_tol</span></code></a>.</p>
<p>This will cause one fitness evaluation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dv</strong> (<em>array-like object</em>) – a decision vector</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if <em>x</em> results in a feasible fitness, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>unspecified</strong> – any exception thrown by <a class="reference internal" href="#pygmo.problem.feasibility_f" title="pygmo.problem.feasibility_f"><code class="xref py py-func docutils literal notranslate"><span class="pre">feasibility_f()</span></code></a> or
    <a class="reference internal" href="#pygmo.problem.fitness" title="pygmo.problem.fitness"><code class="xref py py-func docutils literal notranslate"><span class="pre">fitness()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.fitness">
<code class="sig-name descname">fitness</code><span class="sig-paren">(</span><em class="sig-param">dv</em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.fitness" title="Permalink to this definition">¶</a></dt>
<dd><p>Fitness.</p>
<p>This method will invoke the <code class="docutils literal notranslate"><span class="pre">fitness()</span></code> method of the UDP to compute the fitness of the
input decision vector <em>dv</em>. The return value of the <code class="docutils literal notranslate"><span class="pre">fitness()</span></code> method of the UDP is expected to have a
dimension of <span class="math notranslate nohighlight">\(n_{f} = n_{obj} + n_{ec} + n_{ic}\)</span> and to contain the concatenated values of
<span class="math notranslate nohighlight">\(\mathbf f, \mathbf c_e\)</span> and <span class="math notranslate nohighlight">\(\mathbf c_i\)</span> (in this order).
Equality constraints are all assumed in the form <span class="math notranslate nohighlight">\(c_{e_i}(\mathbf x) = 0\)</span> while inequalities are assumed in
the form <span class="math notranslate nohighlight">\(c_{i_i}(\mathbf x) &lt;= 0\)</span> so that negative values are associated to satisfied inequalities.</p>
<p>In addition to invoking the <code class="docutils literal notranslate"><span class="pre">fitness()</span></code> method of the UDP, this method will perform sanity checks on
<em>dv</em> and on the returned fitness vector. A successful call of this method will increase the internal fitness
evaluation counter (see <a class="reference internal" href="#pygmo.problem.get_fevals" title="pygmo.problem.get_fevals"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_fevals()</span></code></a>).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">fitness()</span></code> method of the UDP must be able to take as input the decision vector as a 1D NumPy array, and it must
return the fitness vector as an iterable Python object (e.g., 1D NumPy array, list, tuple, etc.).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dv</strong> (<em>array-like object</em>) – the decision vector (chromosome) to be evaluated</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the fitness of <em>dv</em></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>1D NumPy float array</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.8)"><strong>ValueError</strong></a> – if either the length of <em>dv</em> differs from the value returned by <a class="reference internal" href="#pygmo.problem.get_nx" title="pygmo.problem.get_nx"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_nx()</span></code></a>, or
    the length of the returned fitness vector differs from the value returned by <a class="reference internal" href="#pygmo.problem.get_nf" title="pygmo.problem.get_nf"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_nf()</span></code></a></p></li>
<li><p><strong>unspecified</strong> – any exception thrown by the <code class="docutils literal notranslate"><span class="pre">fitness()</span></code> method of the UDP, or by failures at the intersection
    between C++ and Python (e.g., type conversion errors, mismatched function signatures, etc.)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.get_bounds">
<code class="sig-name descname">get_bounds</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Box-bounds.</p>
<p>This method will return the box-bounds <span class="math notranslate nohighlight">\((\mathbf{lb}, \mathbf{ub})\)</span> of the problem,
as returned by the <code class="docutils literal notranslate"><span class="pre">get_bounds()</span></code> method of the UDP. Infinities in the bounds are allowed.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">get_bounds()</span></code> method of the UDP must return the box-bounds as a tuple of 2 elements,
the lower bounds vector and the upper bounds vector, which must be represented as iterable Python objects (e.g.,
1D NumPy arrays, lists, tuples, etc.). The box-bounds returned by the UDP are checked upon the construction
of a <a class="reference internal" href="#pygmo.problem" title="pygmo.problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">problem</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a tuple of two 1D NumPy float arrays representing the lower and upper box-bounds of the problem</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">tuple</span></code></p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>unspecified</strong> – any exception thrown by the invoked method of the underlying C++ class, or failures at the
    intersection between C++ and Python (e.g., type conversion errors, mismatched function signatures, etc.)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.get_extra_info">
<code class="sig-name descname">get_extra_info</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_extra_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Problem’s extra info.</p>
<p>If the UDP provides a <code class="docutils literal notranslate"><span class="pre">get_extra_info()</span></code> method, then this method will return the output of its <code class="docutils literal notranslate"><span class="pre">get_extra_info()</span></code>
method. Otherwise, an empty string will be returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>extra info about the UDP</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">str</span></code></p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>unspecified</strong> – any exception thrown by the <code class="docutils literal notranslate"><span class="pre">get_extra_info()</span></code> method of the UDP</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.get_fevals">
<code class="sig-name descname">get_fevals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_fevals" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of fitness evaluations.</p>
<p>Each time a call to <a class="reference internal" href="#pygmo.problem.fitness" title="pygmo.problem.fitness"><code class="xref py py-func docutils literal notranslate"><span class="pre">fitness()</span></code></a> successfully completes, an internal counter
is increased by one. The counter is initialised to zero upon problem construction and it is never
reset. Copy operations copy the counter as well.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the number of times <a class="reference internal" href="#pygmo.problem.fitness" title="pygmo.problem.fitness"><code class="xref py py-func docutils literal notranslate"><span class="pre">fitness()</span></code></a> was successfully called</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.get_gevals">
<code class="sig-name descname">get_gevals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_gevals" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of gradient evaluations.</p>
<p>Each time a call to <a class="reference internal" href="#pygmo.problem.gradient" title="pygmo.problem.gradient"><code class="xref py py-func docutils literal notranslate"><span class="pre">gradient()</span></code></a> successfully completes, an internal counter
is increased by one. The counter is initialised to zero upon problem construction and it is never
reset. Copy operations copy the counter as well.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the number of times <a class="reference internal" href="#pygmo.problem.gradient" title="pygmo.problem.gradient"><code class="xref py py-func docutils literal notranslate"><span class="pre">gradient()</span></code></a> was successfully called</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.get_hevals">
<code class="sig-name descname">get_hevals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_hevals" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of hessians evaluations.</p>
<p>Each time a call to <a class="reference internal" href="#pygmo.problem.hessians" title="pygmo.problem.hessians"><code class="xref py py-func docutils literal notranslate"><span class="pre">hessians()</span></code></a> successfully completes, an internal counter
is increased by one. The counter is initialised to zero upon problem construction and it is never
reset. Copy operations copy the counter as well.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the number of times <a class="reference internal" href="#pygmo.problem.hessians" title="pygmo.problem.hessians"><code class="xref py py-func docutils literal notranslate"><span class="pre">hessians()</span></code></a> was successfully called</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.get_lb">
<code class="sig-name descname">get_lb</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_lb" title="Permalink to this definition">¶</a></dt>
<dd><p>Lower box-bounds.</p>
<p>This method will return the lower box-bounds for this problem. See <a class="reference internal" href="#pygmo.problem.get_bounds" title="pygmo.problem.get_bounds"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_bounds()</span></code></a>
for a detailed explanation of how the bounds are determined.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>an array representing the lower box-bounds of this problem</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>1D NumPy float array</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>unspecified</strong> – any exception thrown by the invoked method of the underlying C++ class, or failures at the
    intersection between C++ and Python (e.g., type conversion errors, mismatched function signatures, etc.)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.get_name">
<code class="sig-name descname">get_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Problem’s name.</p>
<p>If the UDP provides a <code class="docutils literal notranslate"><span class="pre">get_name()</span></code> method, then this method will return the output of its <code class="docutils literal notranslate"><span class="pre">get_name()</span></code> method.
Otherwise, an implementation-defined name based on the type of the UDP will be returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the problem’s name</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">str</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.get_nc">
<code class="sig-name descname">get_nc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_nc" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of constraints.</p>
<p>This method will return the sum of the output of <a class="reference internal" href="#pygmo.problem.get_nic" title="pygmo.problem.get_nic"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_nic()</span></code></a> and
<a class="reference internal" href="#pygmo.problem.get_nec" title="pygmo.problem.get_nec"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_nec()</span></code></a> (i.e., the total number of constraints).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the total number of constraints of the problem</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.get_ncx">
<code class="sig-name descname">get_ncx</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_ncx" title="Permalink to this definition">¶</a></dt>
<dd><p>Continuous dimension of the problem.</p>
<p>This method will return <span class="math notranslate nohighlight">\(n_{cx}\)</span>, the continuous dimension of the problem.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the continuous dimension of the problem</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.get_nec">
<code class="sig-name descname">get_nec</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_nec" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of equality constraints.</p>
<p>This method will return <span class="math notranslate nohighlight">\(n_{ec}\)</span>, the number of equality constraints of the problem.</p>
<p>The optional <code class="docutils literal notranslate"><span class="pre">get_nec()</span></code> method of the UDP must return the number of equality constraints as an <code class="docutils literal notranslate"><span class="pre">int</span></code>.
If the UDP does not implement the <code class="docutils literal notranslate"><span class="pre">get_nec()</span></code> method, zero equality constraints will be assumed.
The number of equality constraints returned by the UDP is checked upon the construction
of a <a class="reference internal" href="#pygmo.problem" title="pygmo.problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">problem</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the number of equality constraints of the problem</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.get_nf">
<code class="sig-name descname">get_nf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_nf" title="Permalink to this definition">¶</a></dt>
<dd><p>Dimension of the fitness.</p>
<p>This method will return <span class="math notranslate nohighlight">\(n_{f}\)</span>, the dimension of the fitness, which is the sum of
<span class="math notranslate nohighlight">\(n_{obj}\)</span>, <span class="math notranslate nohighlight">\(n_{ec}\)</span> and <span class="math notranslate nohighlight">\(n_{ic}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the dimension of the fitness</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.get_nic">
<code class="sig-name descname">get_nic</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_nic" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of inequality constraints.</p>
<p>This method will return <span class="math notranslate nohighlight">\(n_{ic}\)</span>, the number of inequality constraints of the problem.</p>
<p>The optional <code class="docutils literal notranslate"><span class="pre">get_nic()</span></code> method of the UDP must return the number of inequality constraints as an <code class="docutils literal notranslate"><span class="pre">int</span></code>.
If the UDP does not implement the <code class="docutils literal notranslate"><span class="pre">get_nic()</span></code> method, zero inequality constraints will be assumed.
The number of inequality constraints returned by the UDP is checked upon the construction
of a <a class="reference internal" href="#pygmo.problem" title="pygmo.problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">problem</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the number of inequality constraints of the problem</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.get_nix">
<code class="sig-name descname">get_nix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_nix" title="Permalink to this definition">¶</a></dt>
<dd><p>Integer dimension of the problem.</p>
<p>This method will return <span class="math notranslate nohighlight">\(n_{ix}\)</span>, the integer dimension of the problem.</p>
<p>The optional <code class="docutils literal notranslate"><span class="pre">get_nix()</span></code> method of the UDP must return the problem’s integer dimension as an <code class="docutils literal notranslate"><span class="pre">int</span></code>.
If the UDP does not implement the <code class="docutils literal notranslate"><span class="pre">get_nix()</span></code> method, a zero integer dimension will be assumed.
The integer dimension returned by the UDP is checked upon the construction
of a <a class="reference internal" href="#pygmo.problem" title="pygmo.problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">problem</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the integer dimension of the problem</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.get_nobj">
<code class="sig-name descname">get_nobj</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_nobj" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of objectives.</p>
<p>This method will return <span class="math notranslate nohighlight">\(n_{obj}\)</span>, the number of objectives of the problem.</p>
<p>The optional <code class="docutils literal notranslate"><span class="pre">get_nobj()</span></code> method of the UDP must return the number of objectives as an <code class="docutils literal notranslate"><span class="pre">int</span></code>.
If the UDP does not implement the <code class="docutils literal notranslate"><span class="pre">get_nobj()</span></code> method, a single-objective optimizaztion problem
will be assumed. The number of objectives returned by the UDP is checked upon the construction
of a <a class="reference internal" href="#pygmo.problem" title="pygmo.problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">problem</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the number of objectives of the problem</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.get_nx">
<code class="sig-name descname">get_nx</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_nx" title="Permalink to this definition">¶</a></dt>
<dd><p>Dimension of the problem.</p>
<p>This method will return <span class="math notranslate nohighlight">\(n_{x}\)</span>, the dimension of the problem as established by the length of
the bounds returned by <a class="reference internal" href="#pygmo.problem.get_bounds" title="pygmo.problem.get_bounds"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_bounds()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the dimension of the problem</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.get_thread_safety">
<code class="sig-name descname">get_thread_safety</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_thread_safety" title="Permalink to this definition">¶</a></dt>
<dd><p>Problem’s thread safety level.</p>
<p>This method will return a value of the enum <a class="reference internal" href="misc.html#pygmo.thread_safety" title="pygmo.thread_safety"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygmo.thread_safety</span></code></a> which indicates the thread safety level
of the UDP. Unlike in C++, in Python it is not possible to re-implement this method in the UDP. That is, for C++
UDPs, the returned value will be the value returned by the <code class="docutils literal notranslate"><span class="pre">get_thread_safety()</span></code> method of the UDP. For Python
UDPs, the returned value will be unconditionally <code class="docutils literal notranslate"><span class="pre">none</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the thread safety level of the UDP</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>a value of <a class="reference internal" href="misc.html#pygmo.thread_safety" title="pygmo.thread_safety"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygmo.thread_safety</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.get_ub">
<code class="sig-name descname">get_ub</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.get_ub" title="Permalink to this definition">¶</a></dt>
<dd><p>Upper box-bounds.</p>
<p>This method will return the upper box-bounds for this problem. See <a class="reference internal" href="#pygmo.problem.get_bounds" title="pygmo.problem.get_bounds"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_bounds()</span></code></a>
for a detailed explanation of how the bounds are determined.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>an array representing the upper box-bounds of this problem</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>1D NumPy float array</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>unspecified</strong> – any exception thrown by the invoked method of the underlying C++ class, or failures at the
    intersection between C++ and Python (e.g., type conversion errors, mismatched function signatures, etc.)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.gradient">
<code class="sig-name descname">gradient</code><span class="sig-paren">(</span><em class="sig-param">dv</em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Gradient.</p>
<p>This method will compute the gradient of the input decision vector <em>dv</em> by invoking
the <code class="docutils literal notranslate"><span class="pre">gradient()</span></code> method of the UDP. The <code class="docutils literal notranslate"><span class="pre">gradient()</span></code> method of the UDP must return
a sparse representation of the gradient: the <span class="math notranslate nohighlight">\(k\)</span>-th term of the gradient vector
is expected to contain <span class="math notranslate nohighlight">\(\frac{\partial f_i}{\partial x_j}\)</span>, where the pair <span class="math notranslate nohighlight">\((i,j)\)</span>
is the <span class="math notranslate nohighlight">\(k\)</span>-th element of the sparsity pattern (collection of index pairs), as returned by
<a class="reference internal" href="#pygmo.problem.gradient_sparsity" title="pygmo.problem.gradient_sparsity"><code class="xref py py-func docutils literal notranslate"><span class="pre">gradient_sparsity()</span></code></a>.</p>
<p>If the UDP provides a <code class="docutils literal notranslate"><span class="pre">gradient()</span></code> method, this method will forward <em>dv</em> to the <code class="docutils literal notranslate"><span class="pre">gradient()</span></code>
method of the UDP after sanity checks. The output of the <code class="docutils literal notranslate"><span class="pre">gradient()</span></code> method of the UDP will
also be checked before being returned. If the UDP does not provide a <code class="docutils literal notranslate"><span class="pre">gradient()</span></code> method, an
error will be raised. A successful call of this method will increase the internal gradient
evaluation counter (see <a class="reference internal" href="#pygmo.problem.get_gevals" title="pygmo.problem.get_gevals"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_gevals()</span></code></a>).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">gradient()</span></code> method of the UDP must be able to take as input the decision vector as a 1D NumPy
array, and it must return the gradient vector as an iterable Python object (e.g., 1D NumPy array,
list, tuple, etc.).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dv</strong> (<em>array-like object</em>) – the decision vector whose gradient will be computed</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the gradient of <em>dv</em></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>1D NumPy float array</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.8)"><strong>ValueError</strong></a> – if either the length of <em>dv</em> differs from the value returned by <a class="reference internal" href="#pygmo.problem.get_nx" title="pygmo.problem.get_nx"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_nx()</span></code></a>, or
    the returned gradient vector does not have the same size as the vector returned by
    <a class="reference internal" href="#pygmo.problem.gradient_sparsity" title="pygmo.problem.gradient_sparsity"><code class="xref py py-func docutils literal notranslate"><span class="pre">gradient_sparsity()</span></code></a></p></li>
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#NotImplementedError" title="(in Python v3.8)"><strong>NotImplementedError</strong></a> – if the UDP does not provide a <code class="docutils literal notranslate"><span class="pre">gradient()</span></code> method</p></li>
<li><p><strong>unspecified</strong> – any exception thrown by the <code class="docutils literal notranslate"><span class="pre">gradient()</span></code> method of the UDP, or by failures at the intersection
    between C++ and Python (e.g., type conversion errors, mismatched function signatures, etc.)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.gradient_sparsity">
<code class="sig-name descname">gradient_sparsity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.gradient_sparsity" title="Permalink to this definition">¶</a></dt>
<dd><p>Gradient sparsity pattern.</p>
<p>This method will return the gradient sparsity pattern of the problem. The gradient sparsity pattern is a lexicographically sorted
collection of the indices <span class="math notranslate nohighlight">\((i,j)\)</span> of the non-zero elements of <span class="math notranslate nohighlight">\(g_{ij} = \frac{\partial f_i}{\partial x_j}\)</span>.</p>
<p>If <a class="reference internal" href="#pygmo.problem.has_gradient_sparsity" title="pygmo.problem.has_gradient_sparsity"><code class="xref py py-func docutils literal notranslate"><span class="pre">has_gradient_sparsity()</span></code></a> returns <code class="docutils literal notranslate"><span class="pre">True</span></code>, then the <code class="docutils literal notranslate"><span class="pre">gradient_sparsity()</span></code> method of the
UDP will be invoked, and its result returned (after sanity checks). Otherwise, a a dense pattern is assumed and the
returned vector will be <span class="math notranslate nohighlight">\(((0,0),(0,1), ... (0,n_x-1), ...(n_f-1,n_x-1))\)</span>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">gradient_sparsity()</span></code> method of the UDP must return either a 2D NumPy array of integers, or an iterable
Python object of any kind. Specifically:</p>
<ul class="simple">
<li><p>if the returned value is a NumPy array, its shape must be <span class="math notranslate nohighlight">\((n,2)\)</span> (with <span class="math notranslate nohighlight">\(n \geq 0\)</span>),</p></li>
<li><p>if the returned value is an iterable Python object, then its elements must in turn be iterable Python objects
containing each exactly 2 elements representing the indices <span class="math notranslate nohighlight">\((i,j)\)</span>.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the gradient sparsity pattern</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>2D Numpy int array</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.8)"><strong>ValueError</strong></a> – if the NumPy array returned by the UDP does not satisfy the requirements described above (e.g., invalid
    shape, dimensions, etc.),
    at least one element of the returned iterable Python object does not consist of a collection of exactly
    2 elements, or the sparsity pattern returned by the UDP is invalid
    (specifically, if it is not strictly sorted lexicographically,
    or if the indices in the pattern are incompatible with the properties of the problem, or if the size of the
    returned pattern is different from the size recorded upon construction)</p></li>
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#OverflowError" title="(in Python v3.8)"><strong>OverflowError</strong></a> – if the NumPy array returned by the UDP contains integer values which are negative or outside an
    implementation-defined range</p></li>
<li><p><strong>unspecified</strong> – any exception thrown by the underlying C++ function,
    the <code class="docutils literal notranslate"><span class="pre">PyArray_FROM_OTF()</span></code> function from the NumPy C API, or
    failures at the intersection between C++ and Python (e.g., type conversion errors, mismatched function
    signatures, etc.)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.has_batch_fitness">
<code class="sig-name descname">has_batch_fitness</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.has_batch_fitness" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> method is available in the UDP.</p>
<p>This method will return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> method is available in the UDP, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>The availability of the <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> method is determined as follows:</p>
<ul class="simple">
<li><p>if the UDP does not provide a <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> method, then this method will always return <code class="docutils literal notranslate"><span class="pre">False</span></code>;</p></li>
<li><p>if the UDP provides a <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> method but it does not provide a <code class="docutils literal notranslate"><span class="pre">has_batch_fitness()</span></code> method,
then this method will always return <code class="docutils literal notranslate"><span class="pre">True</span></code>;</p></li>
<li><p>if the UDP provides both a <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> and a <code class="docutils literal notranslate"><span class="pre">has_batch_fitness()</span></code> method, then this method will return
the output of the <code class="docutils literal notranslate"><span class="pre">has_batch_fitness()</span></code> method of the UDP.</p></li>
</ul>
<p>The optional <code class="docutils literal notranslate"><span class="pre">has_batch_fitness()</span></code> method of the UDP must return a <code class="docutils literal notranslate"><span class="pre">bool</span></code>. For information on how to
implement the <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> method of the UDP, see <a class="reference internal" href="#pygmo.problem.batch_fitness" title="pygmo.problem.batch_fitness"><code class="xref py py-func docutils literal notranslate"><span class="pre">batch_fitness()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a flag signalling the availability of the <code class="docutils literal notranslate"><span class="pre">batch_fitness()</span></code> method in the UDP</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.has_gradient">
<code class="sig-name descname">has_gradient</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.has_gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the gradient is available in the UDP.</p>
<p>This method will return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the gradient is available in the UDP, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>The availability of the gradient is determined as follows:</p>
<ul class="simple">
<li><p>if the UDP does not provide a <code class="docutils literal notranslate"><span class="pre">gradient()</span></code> method, then this method will always return <code class="docutils literal notranslate"><span class="pre">False</span></code>;</p></li>
<li><p>if the UDP provides a <code class="docutils literal notranslate"><span class="pre">gradient()</span></code> method but it does not provide a <code class="docutils literal notranslate"><span class="pre">has_gradient()</span></code> method,
then this method will always return <code class="docutils literal notranslate"><span class="pre">True</span></code>;</p></li>
<li><p>if the UDP provides both a <code class="docutils literal notranslate"><span class="pre">gradient()</span></code> and a <code class="docutils literal notranslate"><span class="pre">has_gradient()</span></code> method, then this method will return
the output of the <code class="docutils literal notranslate"><span class="pre">has_gradient()</span></code> method of the UDP.</p></li>
</ul>
<p>The optional <code class="docutils literal notranslate"><span class="pre">has_gradient()</span></code> method of the UDP must return a <code class="docutils literal notranslate"><span class="pre">bool</span></code>. For information on how to
implement the <code class="docutils literal notranslate"><span class="pre">gradient()</span></code> method of the UDP, see <a class="reference internal" href="#pygmo.problem.gradient" title="pygmo.problem.gradient"><code class="xref py py-func docutils literal notranslate"><span class="pre">gradient()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a flag signalling the availability of the gradient in the UDP</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.has_gradient_sparsity">
<code class="sig-name descname">has_gradient_sparsity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.has_gradient_sparsity" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the gradient sparsity is available in the UDP.</p>
<p>This method will return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the gradient sparsity is available in the UDP, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>The availability of the gradient sparsity is determined as follows:</p>
<ul class="simple">
<li><p>if the UDP does not provide a <code class="docutils literal notranslate"><span class="pre">gradient_sparsity()</span></code> method, then this method will always return <code class="docutils literal notranslate"><span class="pre">False</span></code>;</p></li>
<li><p>if the UDP provides a <code class="docutils literal notranslate"><span class="pre">gradient_sparsity()</span></code> method but it does not provide a <code class="docutils literal notranslate"><span class="pre">has_gradient_sparsity()</span></code>
method, then this method will always return <code class="docutils literal notranslate"><span class="pre">True</span></code>;</p></li>
<li><p>if the UDP provides both a <code class="docutils literal notranslate"><span class="pre">gradient_sparsity()</span></code> method and a <code class="docutils literal notranslate"><span class="pre">has_gradient_sparsity()</span></code> method,
then this method will return the output of the <code class="docutils literal notranslate"><span class="pre">has_gradient_sparsity()</span></code> method of the UDP.</p></li>
</ul>
<p>The optional <code class="docutils literal notranslate"><span class="pre">has_gradient_sparsity()</span></code> method of the UDP must return a <code class="docutils literal notranslate"><span class="pre">bool</span></code>. For information on how to
implement the <code class="docutils literal notranslate"><span class="pre">gradient_sparsity()</span></code> method of the UDP, see <a class="reference internal" href="#pygmo.problem.gradient_sparsity" title="pygmo.problem.gradient_sparsity"><code class="xref py py-func docutils literal notranslate"><span class="pre">gradient_sparsity()</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Regardless of what this method returns, the <a class="reference internal" href="#pygmo.problem.gradient_sparsity" title="pygmo.problem.gradient_sparsity"><code class="xref py py-func docutils literal notranslate"><span class="pre">gradient_sparsity()</span></code></a> method will always
return a sparsity pattern: if the UDP does not provide the gradient sparsity, pygmo will assume that the sparsity
pattern of the gradient is dense. See <a class="reference internal" href="#pygmo.problem.gradient_sparsity" title="pygmo.problem.gradient_sparsity"><code class="xref py py-func docutils literal notranslate"><span class="pre">gradient_sparsity()</span></code></a> for more details.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a flag signalling the availability of the gradient sparsity in the UDP</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.has_hessians">
<code class="sig-name descname">has_hessians</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.has_hessians" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the hessians are available in the UDP.</p>
<p>This method will return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the hessians are available in the UDP, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>The availability of the hessians is determined as follows:</p>
<ul class="simple">
<li><p>if the UDP does not provide a <code class="docutils literal notranslate"><span class="pre">hessians()</span></code> method, then this method will always return <code class="docutils literal notranslate"><span class="pre">False</span></code>;</p></li>
<li><p>if the UDP provides a <code class="docutils literal notranslate"><span class="pre">hessians()</span></code> method but it does not provide a <code class="docutils literal notranslate"><span class="pre">has_hessians()</span></code> method,
then this method will always return <code class="docutils literal notranslate"><span class="pre">True</span></code>;</p></li>
<li><p>if the UDP provides both a <code class="docutils literal notranslate"><span class="pre">hessians()</span></code> and a <code class="docutils literal notranslate"><span class="pre">has_hessians()</span></code> method, then this method will return
the output of the <code class="docutils literal notranslate"><span class="pre">has_hessians()</span></code> method of the UDP.</p></li>
</ul>
<p>The optional <code class="docutils literal notranslate"><span class="pre">has_hessians()</span></code> method of the UDP must return a <code class="docutils literal notranslate"><span class="pre">bool</span></code>. For information on how to
implement the <code class="docutils literal notranslate"><span class="pre">hessians()</span></code> method of the UDP, see <a class="reference internal" href="#pygmo.problem.hessians" title="pygmo.problem.hessians"><code class="xref py py-func docutils literal notranslate"><span class="pre">hessians()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a flag signalling the availability of the hessians in the UDP</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.has_hessians_sparsity">
<code class="sig-name descname">has_hessians_sparsity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.has_hessians_sparsity" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the hessians sparsity is available in the UDP.</p>
<p>This method will return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the hessians sparsity is available in the UDP, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>The availability of the hessians sparsity is determined as follows:</p>
<ul class="simple">
<li><p>if the UDP does not provide a <code class="docutils literal notranslate"><span class="pre">hessians_sparsity()</span></code> method, then this method will always return <code class="docutils literal notranslate"><span class="pre">False</span></code>;</p></li>
<li><p>if the UDP provides a <code class="docutils literal notranslate"><span class="pre">hessians_sparsity()</span></code> method but it does not provide a <code class="docutils literal notranslate"><span class="pre">has_hessians_sparsity()</span></code>
method, then this method will always return <code class="docutils literal notranslate"><span class="pre">True</span></code>;</p></li>
<li><p>if the UDP provides both a <code class="docutils literal notranslate"><span class="pre">hessians_sparsity()</span></code> method and a <code class="docutils literal notranslate"><span class="pre">has_hessians_sparsity()</span></code> method,
then this method will return the output of the <code class="docutils literal notranslate"><span class="pre">has_hessians_sparsity()</span></code> method of the UDP.</p></li>
</ul>
<p>The optional <code class="docutils literal notranslate"><span class="pre">has_hessians_sparsity()</span></code> method of the UDP must return a <code class="docutils literal notranslate"><span class="pre">bool</span></code>. For information on how to
implement the <code class="docutils literal notranslate"><span class="pre">hessians_sparsity()</span></code> method of the UDP, see <a class="reference internal" href="#pygmo.problem.hessians_sparsity" title="pygmo.problem.hessians_sparsity"><code class="xref py py-func docutils literal notranslate"><span class="pre">hessians_sparsity()</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Regardless of what this method returns, the <a class="reference internal" href="#pygmo.problem.hessians_sparsity" title="pygmo.problem.hessians_sparsity"><code class="xref py py-func docutils literal notranslate"><span class="pre">hessians_sparsity()</span></code></a> method will always
return a sparsity pattern: if the UDP does not provide the hessians sparsity, pygmo will assume that the sparsity
pattern of the hessians is dense. See <a class="reference internal" href="#pygmo.problem.hessians_sparsity" title="pygmo.problem.hessians_sparsity"><code class="xref py py-func docutils literal notranslate"><span class="pre">hessians_sparsity()</span></code></a> for more details.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a flag signalling the availability of the hessians sparsity in the UDP</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.has_set_seed">
<code class="sig-name descname">has_set_seed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.has_set_seed" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the <code class="docutils literal notranslate"><span class="pre">set_seed()</span></code> method is available in the UDP.</p>
<p>This method will return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the <code class="docutils literal notranslate"><span class="pre">set_seed()</span></code> method is available in the UDP, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>The availability of the <code class="docutils literal notranslate"><span class="pre">set_seed()</span></code> method is determined as follows:</p>
<ul class="simple">
<li><p>if the UDP does not provide a <code class="docutils literal notranslate"><span class="pre">set_seed()</span></code> method, then this method will always return <code class="docutils literal notranslate"><span class="pre">False</span></code>;</p></li>
<li><p>if the UDP provides a <code class="docutils literal notranslate"><span class="pre">set_seed()</span></code> method but it does not provide a <code class="docutils literal notranslate"><span class="pre">has_set_seed()</span></code> method,
then this method will always return <code class="docutils literal notranslate"><span class="pre">True</span></code>;</p></li>
<li><p>if the UDP provides both a <code class="docutils literal notranslate"><span class="pre">set_seed()</span></code> and a <code class="docutils literal notranslate"><span class="pre">has_set_seed()</span></code> method, then this method will return
the output of the <code class="docutils literal notranslate"><span class="pre">has_set_seed()</span></code> method of the UDP.</p></li>
</ul>
<p>The optional <code class="docutils literal notranslate"><span class="pre">has_set_seed()</span></code> method of the UDP must return a <code class="docutils literal notranslate"><span class="pre">bool</span></code>. For information on how to
implement the <code class="docutils literal notranslate"><span class="pre">set_seed()</span></code> method of the UDP, see <a class="reference internal" href="#pygmo.problem.set_seed" title="pygmo.problem.set_seed"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_seed()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a flag signalling the availability of the <code class="docutils literal notranslate"><span class="pre">set_seed()</span></code> method in the UDP</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.hessians">
<code class="sig-name descname">hessians</code><span class="sig-paren">(</span><em class="sig-param">dv</em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.hessians" title="Permalink to this definition">¶</a></dt>
<dd><p>Hessians.</p>
<p>This method will compute the hessians of the input decision vector <em>dv</em> by invoking
the <code class="docutils literal notranslate"><span class="pre">hessians()</span></code> method of the UDP. The <code class="docutils literal notranslate"><span class="pre">hessians()</span></code> method of the UDP must return
a sparse representation of the hessians: the element <span class="math notranslate nohighlight">\(l\)</span> of the returned vector contains
<span class="math notranslate nohighlight">\(h^l_{ij} = \frac{\partial f^2_l}{\partial x_i\partial x_j}\)</span> in the order specified by the
<span class="math notranslate nohighlight">\(l\)</span>-th element of the hessians sparsity pattern (a vector of index pairs <span class="math notranslate nohighlight">\((i,j)\)</span>)
as returned by <a class="reference internal" href="#pygmo.problem.hessians_sparsity" title="pygmo.problem.hessians_sparsity"><code class="xref py py-func docutils literal notranslate"><span class="pre">hessians_sparsity()</span></code></a>. Since
the hessians are symmetric, their sparse representation contains only lower triangular elements.</p>
<p>If the UDP provides a <code class="docutils literal notranslate"><span class="pre">hessians()</span></code> method, this method will forward <em>dv</em> to the <code class="docutils literal notranslate"><span class="pre">hessians()</span></code>
method of the UDP after sanity checks. The output of the <code class="docutils literal notranslate"><span class="pre">hessians()</span></code> method of the UDP will
also be checked before being returned. If the UDP does not provide a <code class="docutils literal notranslate"><span class="pre">hessians()</span></code> method, an
error will be raised. A successful call of this method will increase the internal hessians
evaluation counter (see <a class="reference internal" href="#pygmo.problem.get_hevals" title="pygmo.problem.get_hevals"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_hevals()</span></code></a>).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">hessians()</span></code> method of the UDP must be able to take as input the decision vector as a 1D NumPy
array, and it must return the hessians vector as an iterable Python object (e.g., list, tuple, etc.).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dv</strong> (<em>array-like object</em>) – the decision vector whose hessians will be computed</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the hessians of <em>dv</em></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">list</span></code> of 1D NumPy float array</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.8)"><strong>ValueError</strong></a> – if the length of <em>dv</em> differs from the value returned by <a class="reference internal" href="#pygmo.problem.get_nx" title="pygmo.problem.get_nx"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_nx()</span></code></a>, or
    the length of returned hessians does not match the corresponding hessians sparsity pattern dimensions, or
    the size of the return value is not equal to the fitness dimension</p></li>
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#NotImplementedError" title="(in Python v3.8)"><strong>NotImplementedError</strong></a> – if the UDP does not provide a <code class="docutils literal notranslate"><span class="pre">hessians()</span></code> method</p></li>
<li><p><strong>unspecified</strong> – any exception thrown by the <code class="docutils literal notranslate"><span class="pre">hessians()</span></code> method of the UDP, or by failures at the intersection
    between C++ and Python (e.g., type conversion errors, mismatched function signatures, etc.)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.hessians_sparsity">
<code class="sig-name descname">hessians_sparsity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.hessians_sparsity" title="Permalink to this definition">¶</a></dt>
<dd><p>Hessians sparsity pattern.</p>
<p>This method will return the hessians sparsity pattern of the problem. Each component <span class="math notranslate nohighlight">\(l\)</span> of the hessians
sparsity pattern is a lexicographically sorted collection of the indices <span class="math notranslate nohighlight">\((i,j)\)</span> of the non-zero elements of
<span class="math notranslate nohighlight">\(h^l_{ij} = \frac{\partial f^l}{\partial x_i\partial x_j}\)</span>. Since the Hessian matrix is symmetric, only
lower triangular elements are allowed.</p>
<p>If <a class="reference internal" href="#pygmo.problem.has_hessians_sparsity" title="pygmo.problem.has_hessians_sparsity"><code class="xref py py-func docutils literal notranslate"><span class="pre">has_hessians_sparsity()</span></code></a> returns <code class="docutils literal notranslate"><span class="pre">True</span></code>, then the <code class="docutils literal notranslate"><span class="pre">hessians_sparsity()</span></code> method of the
UDP will be invoked, and its result returned (after sanity checks). Otherwise, a dense pattern is assumed and
<span class="math notranslate nohighlight">\(n_f\)</span> sparsity patterns containing <span class="math notranslate nohighlight">\(((0,0),(1,0), (1,1), (2,0) ... (n_x-1,n_x-1))\)</span> will be returned.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">hessians_sparsity()</span></code> method of the UDP must return an iterable Python object of any kind. Each element of the
returned object will then be interpreted as a sparsity pattern in the same way as described in
<a class="reference internal" href="#pygmo.problem.gradient_sparsity" title="pygmo.problem.gradient_sparsity"><code class="xref py py-func docutils literal notranslate"><span class="pre">gradient_sparsity()</span></code></a>. Specifically:</p>
<ul class="simple">
<li><p>if the element is a NumPy array, its shape must be <span class="math notranslate nohighlight">\((n,2)\)</span> (with <span class="math notranslate nohighlight">\(n \geq 0\)</span>),</p></li>
<li><p>if the element is itself an iterable Python object, then its elements must in turn be iterable Python objects
containing each exactly 2 elements representing the indices <span class="math notranslate nohighlight">\((i,j)\)</span>.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the hessians sparsity patterns</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">list</span></code> of 2D Numpy int array</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.8)"><strong>ValueError</strong></a> – if the NumPy arrays returned by the UDP do not satisfy the requirements described above (e.g., invalid
    shape, dimensions, etc.),
    at least one element of a returned iterable Python object does not consist of a collection of exactly
    2 elements, or if a sparsity pattern returned by the UDP is invalid (specifically, if it is not strictly sorted lexicographically,
    if the indices in the pattern are incompatible with the properties of the problem or if the size of the pattern
    differs from the size recorded upon construction)</p></li>
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#OverflowError" title="(in Python v3.8)"><strong>OverflowError</strong></a> – if the NumPy arrays returned by the UDP contain integer values which are negative or outside an
    implementation-defined range</p></li>
<li><p><strong>unspecified</strong> – any exception thrown by the underlying C++ function,
    the <code class="docutils literal notranslate"><span class="pre">PyArray_FROM_OTF()</span></code> function from the NumPy C API, or
    failures at the intersection between C++ and Python (e.g., type conversion errors, mismatched function
    signatures, etc.)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.increment_fevals">
<code class="sig-name descname">increment_fevals</code><span class="sig-paren">(</span><em class="sig-param">n</em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.increment_fevals" title="Permalink to this definition">¶</a></dt>
<dd><p>Increment the number of fitness evaluations.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 2.13.</span></p>
</div>
<p>This method will increase the internal counter of fitness evaluations by <em>n</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) – the amount by which the internal counter of fitness evaluations will be increased</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>unspecified</strong> – any exception thrown by failures at the intersection between C++ and Python (e.g.,
    type conversion errors, mismatched function signatures, etc.)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.is_">
<code class="sig-name descname">is_</code><span class="sig-paren">(</span><em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.is_" title="Permalink to this definition">¶</a></dt>
<dd><p>Check the type of the user-defined problem.</p>
<p>This method returns <a class="reference external" href="https://docs.python.org/3/library/constants.html#False" title="(in Python v3.8)"><code class="xref py py-data docutils literal notranslate"><span class="pre">False</span></code></a> if <a class="reference internal" href="#pygmo.problem.extract" title="pygmo.problem.extract"><code class="xref py py-func docutils literal notranslate"><span class="pre">extract(t)</span></code></a> returns
<a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.8)"><code class="xref py py-data docutils literal notranslate"><span class="pre">None</span></code></a>, and <a class="reference external" href="https://docs.python.org/3/library/constants.html#True" title="(in Python v3.8)"><code class="xref py py-data docutils literal notranslate"><span class="pre">True</span></code></a> otherwise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>t</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#type" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a>) – the type that will be compared to the type of the UDP</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>whether the UDP is of type <em>t</em> or not</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)">bool</a></p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>unspecified</strong> – any exception thrown by <a class="reference internal" href="#pygmo.problem.extract" title="pygmo.problem.extract"><code class="xref py py-func docutils literal notranslate"><span class="pre">extract()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.is_stochastic">
<code class="sig-name descname">is_stochastic</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.is_stochastic" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for <a class="reference internal" href="#pygmo.problem.has_set_seed" title="pygmo.problem.has_set_seed"><code class="xref py py-func docutils literal notranslate"><span class="pre">has_set_seed()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="pygmo.problem.set_seed">
<code class="sig-name descname">set_seed</code><span class="sig-paren">(</span><em class="sig-param">seed</em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.problem.set_seed" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the seed for the stochastic variables.</p>
<p>This method will set the seed to be used in the fitness function to instantiate
all stochastic variables. If the UDP provides a <code class="docutils literal notranslate"><span class="pre">set_seed()</span></code> method, then
its <code class="docutils literal notranslate"><span class="pre">set_seed()</span></code> method will be invoked. Otherwise, an error will be raised.
The <em>seed</em> parameter must be non-negative.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">set_seed()</span></code> method of the UDP must be able to take an <code class="docutils literal notranslate"><span class="pre">int</span></code> as input parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>seed</strong> (<code class="docutils literal notranslate"><span class="pre">int</span></code>) – the desired seed value</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#NotImplementedError" title="(in Python v3.8)"><strong>NotImplementedError</strong></a> – if the UDP does not provide a <code class="docutils literal notranslate"><span class="pre">set_seed()</span></code> method</p></li>
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#OverflowError" title="(in Python v3.8)"><strong>OverflowError</strong></a> – if <em>seed</em> is negative</p></li>
<li><p><strong>unspecified</strong> – any exception raised by the <code class="docutils literal notranslate"><span class="pre">set_seed()</span></code> method of the UDP or failures at the intersection
    between C++ and Python (e.g., type conversion errors, mismatched function signatures, etc.)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="population.html" class="btn btn-neutral float-right" title="Population class" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="algorithm.html" class="btn btn-neutral float-left" title="Algorithm class" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, pagmo development team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>